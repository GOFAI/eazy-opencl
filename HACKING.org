

Design Architechture:

* Error handling (layer 1)

This layer wraps the bare CFFI api with error handling.

OpenCL APIs can be divided into three categories of functions:

1. It does not return any error
2. The return value (cl_int) tells the error situation
3. Takes a pointer to cl_int in the last argument, then sets the error value to that address

In error-handlers.lisp, `wrap-api-returning-error` handles the second case
and `wrap-api-taking-error-ptr` handles the third case.

* Convert the imperative C apis -> functional apis. (layer 2)

This layer handles more about pointers, including properties and arrays.

Error handling is already achieved by the previous layer.
What we do now is to convert to/from foreign type,
or to handle the apis which returns the result by setting it to the given pointer.

Original api names are maintained. Some are re-exported from level-1, some
are newly interned and exported.

* Garbage collection (layer 3)

We do not use RETAIN interface, and instead use the garbage collector of
the host lisp. If the object is unreachable from the memory space of the
host lisp, then it RELEASE the object once, decrementing the reference
count. (There might be more references from the opencl
implementation itself, in which case the object is not freed immediately.)
This is realized through trivial-garbage:finalize.

* Class Wrapper?

Context, program, kernel, device, commandqueue can be wrapped in a CLOS
layer. The overhead must be smaller than the large computation done by
opencl.

This does not mean that the wrapper should be very fast.  If this overhead
is a problem, then it also means that your application contains a large
number of very costly GPU-MEMORY communications, required each time the
GPGPU computation is initialized. In such cases, you should instead
consider changing the algorithm or even stop using GPGPU.
